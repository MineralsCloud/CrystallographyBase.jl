var documenterSearchIndex = {"docs":
[{"location":"man/troubleshooting/#Troubleshooting","page":"Troubleshooting","title":"Troubleshooting","text":"Pages = [\"troubleshooting.md\"]\nDepth = 2:2\n\nThis page lists possible errors you may encounter and provides tips on how to fix them. If you have any questions about how to use this code, feel free to discuss with us.\n\nIf you have additional tips, please either report an issue or submit a pull request with suggestions.","category":"section"},{"location":"man/troubleshooting/#Cannot-find-the-Julia-executable","page":"Troubleshooting","title":"Cannot find the Julia executable","text":"Ensure that Julia is installed in your environment. Please download the latest stable version for your platform, and it's recommended to do it indirectly with Juliaup as explained on that page.\n\nIf you prefer not to install Juliaup, download the corresponding binaries instead. Next, create a symbolic link to the Julia executable. If the path is not included in your $PATH environment variable, add it by exporting the path to $PATH.\n\nSome clusters, like Comet, or Expanse, already have Julia installed as a module, you can just module load julia to use it. If not, you should either install it yourself or contact your system administrator.\n\nSee Installation Guide for more information.","category":"section"},{"location":"man/troubleshooting/#Julia-starts-slow","page":"Troubleshooting","title":"Julia starts slow","text":"First, we recommend downloading the latest version of Julia using Juliaup. Usually, the latest version has the best performance.\n\nFor simple, one-time tasks in Julia, you can start the Julia REPL with\n\njulia --compile=min\n\nto minimize compilation or\n\njulia --optimize=0\n\nto minimize optimizations. Or you could make a system image and run with\n\njulia --sysimage custom-image.so\n\nSee Fredrik Ekre's talk for details.","category":"section"},{"location":"lib/internals/lattices/#Lattices","page":"Lattices","title":"Lattices","text":"","category":"section"},{"location":"lib/internals/lattices/#CrystallographyCore.AbstractLattice","page":"Lattices","title":"CrystallographyCore.AbstractLattice","text":"AbstractLattice{T}\n\nRepresent the real lattices and the reciprocal lattices.\n\n\n\n\n\n","category":"type"},{"location":"man/definitions/#Definitions-and-conventions","page":"Definitions and conventions","title":"Definitions and conventions","text":"Pages = [\"definitions.md\"]\nDepth = 2","category":"section"},{"location":"man/definitions/#Basis-vectors","page":"Definitions and conventions","title":"Basis vectors","text":"In this package, basis vectors are represented by three-column vectors:\n\nmathbfa = beginbmatrix\n    a_x \n    a_y \n    a_z\nendbmatrix\nquad\nmathbfb = beginbmatrix\n    b_x \n    b_y \n    b_z\nendbmatrix\nquad\nmathbfc = beginbmatrix\n    c_x \n    c_y \n    c_z\nendbmatrix\n\nin Cartesian coordinates. Depending on the situation, beginbmatrix mathbfa_1  mathbfa_2  mathbfa_3 endbmatrix is used instead of beginbmatrix mathbfa  mathbfb  mathbfc endbmatrix.\n\nTherefore, a lattice is represented as\n\nmathrmA =\nbeginbmatrix mathbfa  mathbfb  mathbfc endbmatrix =\nbeginbmatrix\n    a_x  b_x  c_x \n    a_y  b_y  c_y \n    a_z  b_z  c_z\nendbmatrix\n\nA reciprocal lattice is its inverse, represented as three row vectors:\n\nmathrmB =\nmathrmA^-1 =\nbeginbmatrix\n    mathbfb_1 \n    mathbfb_2 \n    mathbfb_3\nendbmatrix\n\nso that\n\nmathrmA mathrmB = mathrmB mathrmA = mathrmI\n\nwhere mathrmI is the 3 times 3 identity matrix.","category":"section"},{"location":"man/definitions/#Crystal-coordinates","page":"Definitions and conventions","title":"Crystal coordinates","text":"Coordinates of an atomic point mathbfx are represented as three fractional values relative to basis vectors as follows,\n\nmathbfx = beginbmatrix\n    x_1 \n    x_2 \n    x_3\nendbmatrix\n\nwhere 0 le x_i  1. A position vector mathbfr in Cartesian coordinates is obtained by\n\nmathbfr = mathrmA mathbfx = beginbmatrix mathbfa_1  mathbfa_2  mathbfa_3 endbmatrix mathbfx\n\nor\n\nmathbfr = sum_i x_i mathbfa_i","category":"section"},{"location":"man/definitions/#primitive","page":"Definitions and conventions","title":"Transformation to the primitive cell","text":"In the standardized unit cells, there are five different centring types available, base centrings of A and C, rhombohedral (R), body-centred (I), and face-centred (F). The transformation is applied to the standardized unit cell by\n\nbeginbmatrix mathbfa_p  mathbfb_p  mathbfc_p endbmatrix =\nbeginbmatrix mathbfa_s  mathbfb_s  mathbfc_s endbmatrix\nmathrmP\n\nwhere mathbfa_p, mathbfb_p, and mathbfc_p are the basis vectors of the primitive cell and mathrmP is the transformation matrix from the standardized unit cell to the primitive cell. Matrices mathrmP for different centring types are given as follows:\n\nmathrmP_textA = beginbmatrix\n    1  0  0 \n    0  dfrac12  dfrac-12 \n    0  dfrac12  dfrac12\nendbmatrix\nquad\nmathrmP_textC = beginbmatrix\n    dfrac12  dfrac12  0 \n    dfrac-12  dfrac12  0 \n    0  0  1\nendbmatrix\nquad\nmathrmP_textR = beginbmatrix\n    dfrac23  dfrac-13  dfrac-13 \n    dfrac13  dfrac13  dfracbar23 \n    dfrac13  dfrac13  dfrac13\nendbmatrix\nquad\nmathrmP_textI = beginbmatrix\n    dfrac-12  dfrac12  dfrac12 \n    dfrac12  dfrac-12  dfrac12 \n    dfrac12  dfrac12  dfrac-12\nendbmatrix\nquad\nmathrmP_textF = beginbmatrix\n    0  dfrac12  dfrac12 \n    dfrac12  0  dfrac12 \n    dfrac12  dfrac12  0\nendbmatrix\n\nThe choice of transformation matrix depends on the purpose.\n\nFor rhombohedral lattice systems with the H setting (hexagonal lattice), mathrmP_textR is applied to obtain primitive basis vectors. However, with the R setting (rhombohedral lattice), no transformation matrix is used because it is already a primitive cell.","category":"section"},{"location":"man/definitions/#Supercell-generation","page":"Definitions and conventions","title":"Supercell generation","text":"The basis vectors of unit cell beginbmatrix mathbfa_1  mathbfa_2  mathbfa_3 endbmatrix can be transformed to basis vectors of supercell beginbmatrix mathbfa_1  mathbfa_2  mathbfa_3 endbmatrix by linear transformation\n\nbeginbmatrix mathbfa_1  mathbfa_2  mathbfa_3 endbmatrix =\nbeginbmatrix mathbfa_1  mathbfa_2  mathbfa_3 endbmatrix\nmathrmP\n\njust as in primitive cell transformations.\n\nUsually, all elements P_ij should be integers satisfying i ne 0 so that det(mathrmP) ge 1. When det(mathrmP) = 1, the transformation preserves volume. However, sometimes we could have det(mathrmP)  0 if the transformation changes the handedness of the lattice. See this post for more information.\n\nAs stated above, a new (super)cell is produced by replication of the initial one over cell vectors mathbfa, mathbfb, and mathbfc. The new cell will have a size of l mathbfa times m mathbfb times n mathbfc. Each crystallographic site in the initial cell with Cartesian coordinates mathbfr will have a total of l m n images in the supercell with Cartesian coordinates\n\nmathbfr^i j k = mathbfr + i mathbfa + j mathbfb + k mathbfc\n\nwhere i = 0 1 ldots l - 1, m = 0 1 ldots m - 1, and k = 0 1 ldots n - 1 (See this paper).\n\nIt is important to keep in mind that this supercell expansion approach is a special case: the simplest one. It does not allow, for example, transformations of a primitive cell into a conventional (super)cell or the opposite. A more general approach exists, which creates supercell vectors on the basis of linear combinations of the initial cell vectors, a desirable improvement that will be considered for a future version of the code.","category":"section"},{"location":"developers/contributing/#Contributing","page":"Contributing","title":"Contributing","text":"Pages = [\"contributing.md\"]\nDepth = 2:3\n\nWelcome! This document explains some ways you can contribute to CrystallographyBase.","category":"section"},{"location":"developers/contributing/#Code-of-conduct","page":"Contributing","title":"Code of conduct","text":"This project and everyone participating in it is governed by the Contributor Covenant Code of Conduct. By participating, you are expected to uphold this code.","category":"section"},{"location":"developers/contributing/#Join-the-community-forum","page":"Contributing","title":"Join the community forum","text":"First up, join the community forum.\n\nThe forum is a good place to ask questions about how to use CrystallographyBase. You can also use the forum to discuss possible feature requests and bugs before raising a GitHub issue (more on this below).\n\nAside from asking questions, the easiest way you can contribute to CrystallographyBase is to help answer questions on the forum!","category":"section"},{"location":"developers/contributing/#Improve-the-documentation","page":"Contributing","title":"Improve the documentation","text":"Chances are, if you asked (or answered) a question on the community forum, then it is a sign that the documentation could be improved. Moreover, since it is your question, you are probably the best-placed person to improve it!\n\nThe docs are written in Markdown and are built using Documenter.jl. You can find the source of all the docs here.\n\nIf your change is small (like fixing typos or one or two sentence corrections), the easiest way to do this is via GitHub's online editor. (GitHub has help on how to do this.)\n\nIf your change is larger or touches multiple files, you will need to make the change locally and then use Git to submit a pull request. (See Contribute code to CrystallographyBase below for more on this.)","category":"section"},{"location":"developers/contributing/#File-a-bug-report","page":"Contributing","title":"File a bug report","text":"Another way to contribute to CrystallographyBase is to file bug reports.\n\nMake sure you read the info in the box where you write the body of the issue before posting. You can also find a copy of that info here.\n\ntip: Tip\nIf you're unsure whether you have a real bug, post on the community forum first. Someone will either help you fix the problem or let you know the most appropriate place to open a bug report.","category":"section"},{"location":"developers/contributing/#Contribute-code-to-CrystallographyBase","page":"Contributing","title":"Contribute code to CrystallographyBase","text":"Finally, you can also contribute code to CrystallographyBase!\n\nwarning: Warning\nIf you do not have experience with Git, GitHub, and Julia development, the first steps can be a little daunting. However, there are lots of tutorials available online, including:GitHub\nGit and GitHub\nGit\nJulia package development\n\nOnce you are familiar with Git and GitHub, the workflow for contributing code to CrystallographyBase is similar to the following:","category":"section"},{"location":"developers/contributing/#Step-1:-decide-what-to-work-on","page":"Contributing","title":"Step 1: decide what to work on","text":"The first step is to find an open issue (or open a new one) for the problem you want to solve. Then, before spending too much time on it, discuss what you are planning to do in the issue to see if other contributors are fine with your proposed changes. Getting feedback early can improve code quality and avoid time spent writing code that does not get merged into CrystallographyBase.\n\ntip: Tip\nAt this point, remember to be patient and polite; you may get a lot of comments on your issue! However, do not be afraid! Comments mean that people are willing to help you improve the code that you are contributing to CrystallographyBase.","category":"section"},{"location":"developers/contributing/#Step-2:-fork-CrystallographyBase","page":"Contributing","title":"Step 2: fork CrystallographyBase","text":"Go to https://github.com/MineralsCloud/CrystallographyBase.jl and click the \"Fork\" button in the top-right corner. This will create a copy of CrystallographyBase under your GitHub account.","category":"section"},{"location":"developers/contributing/#Step-3:-install-CrystallographyBase-locally","page":"Contributing","title":"Step 3: install CrystallographyBase locally","text":"Similar to Installation Guide, open the Julia REPL and run:\n\nusing Pkg\nPkg.update()\nPkg.develop(\"CrystallographyBase\")\n\nThen the package will be cloned to your local machine. On *nix systems, the default path is ~/.julia/dev/CrystallographyBase unless you modify the JULIA_DEPOT_PATH environment variable. If you're on Windows, this will be C:\\\\Users\\\\<my_name>\\\\.julia\\\\dev\\\\CrystallographyBase. In the following text, we will call it PKGROOT.\n\nGo to PKGROOT, start a new Julia session, and run\n\nusing Pkg\nPkg.instantiate()\n\nto instantiate the project.","category":"section"},{"location":"developers/contributing/#Step-4:-checkout-a-new-branch","page":"Contributing","title":"Step 4: checkout a new branch","text":"note: Note\nIn the following, replace any instance of GITHUB_ACCOUNT with your GitHub username.\n\nThe next step is to check out a development branch. In a terminal (or command prompt on Windows), run:\n\n$ cd ~/.julia/dev/CrystallographyBase\n\n$ git remote add GITHUB_ACCOUNT https://github.com/GITHUB_ACCOUNT/CrystallographyBase.jl.git\n\n$ git checkout main\n\n$ git pull\n\n$ git checkout -b my_new_branch","category":"section"},{"location":"developers/contributing/#Step-5:-make-changes","page":"Contributing","title":"Step 5: make changes","text":"Now make any changes to the source code inside the ~/.julia/dev/CrystallographyBase directory.\n\nMake sure you:\n\nFollow our Style Guide and Run JuliaFormatter.\nAdd tests and documentation for any changes or new features.\n\ntip: Tip\nWhen you change the source code, you will need to restart Julia for the changes to take effect. If this is a pain, install Revise.jl.","category":"section"},{"location":"developers/contributing/#Step-6a:-test-your-code-changes","page":"Contributing","title":"Step 6a: test your code changes","text":"To test that your changes work, run the CrystallographyBase test-suite by opening Julia and running:\n\njulia> cd(joinpath(DEPOT_PATH[1], \"dev\", \"CrystallographyBase\"))\n\njulia> using Pkg\n\njulia> Pkg.activate(\".\")\n  Activating new project at `~/.julia/dev/CrystallographyBase`\n\njulia> Pkg.test()\n\nwarning: Warning\nRunning the tests might take a long time.\n\ntip: Tip\nIf you are using Revise.jl, you can also run the tests by calling include:include(\"test/runtests.jl\")This can be faster if you want to re-run the tests multiple times.","category":"section"},{"location":"developers/contributing/#Step-6b:-test-your-documentation-changes","page":"Contributing","title":"Step 6b: test your documentation changes","text":"Open Julia, then run:\n\njulia> cd(joinpath(DEPOT_PATH[1], \"dev\", \"CrystallographyBase\", \"docs\"))\n\njulia> using Pkg\n\njulia> Pkg.activate(\".\")\n  Activating new project at `~/.julia/dev/CrystallographyBase/docs`\n\njulia> include(\"src/make.jl\")\n\nAfter a while, a folder PKGROOT/docs/build will appear. Open PKGROOT/docs/build/index.html with your favorite browser, and have fun!\n\nwarning: Warning\nBuilding the documentation might take a long time.\n\ntip: Tip\nIf there's a problem with the tests that you don't know how to fix, don't worry. Continue to step 5, and one of the CrystallographyBase contributors will comment on your pull request, telling you how to fix things.","category":"section"},{"location":"developers/contributing/#Step-7:-make-a-pull-request","page":"Contributing","title":"Step 7: make a pull request","text":"Once you've made changes, you're ready to push the changes to GitHub. Run:\n\n$ cd ~/.julia/dev/CrystallographyBase\n\n$ git add .\n\n$ git commit -m \"A descriptive message of the changes\"\n\n$ git push -u GITHUB_ACCOUNT my_new_branch\n\nThen go to our pull request page and follow the instructions that pop up to open a pull request.","category":"section"},{"location":"developers/contributing/#Step-8:-respond-to-comments","page":"Contributing","title":"Step 8: respond to comments","text":"At this point, remember to be patient and polite; you may get a lot of comments on your pull request! However, do not be afraid! A lot of comments means that people are willing to help you improve the code that you are contributing to CrystallographyBase.\n\nTo respond to the comments, go back to step 5, make any changes, test the changes in step 6, and then make a new commit in step 7. Your PR will automatically update.","category":"section"},{"location":"developers/contributing/#Step-9:-cleaning-up","page":"Contributing","title":"Step 9: cleaning up","text":"Once the PR is merged, clean-up your Git repository, ready for the next contribution!\n\n$ cd ~/.julia/dev/CrystallographyBase\n\n$ git checkout main\n\n$ git pull\n\nnote: Note\nIf you have suggestions to improve this guide, please make a pull request! It's particularly helpful if you do this after your first pull request because you'll know all the parts that could be explained better.\n\nThanks for contributing to CrystallographyBase!","category":"section"},{"location":"developers/design-principles/#Design-Principles","page":"Design Principles","title":"Design Principles","text":"Pages = [\"design-principles.md\"]\nDepth = 2:2\n\nWe adopt some SciML design guidelines here. Please read them before contributing!","category":"section"},{"location":"developers/design-principles/#Consistency-vs-adherence","page":"Design Principles","title":"Consistency vs adherence","text":"According to PEP8:\n\nA style guide is about consistency. Consistency with this style guide is important. Consistency within a project is more important. Consistency within one module or function is the most important.However, know when to be inconsistentâ€”sometimes style guide recommendations just aren't applicable. When in doubt, use your best judgment. Look at other examples and decide what looks best. And donâ€™t hesitate to ask!","category":"section"},{"location":"developers/design-principles/#Community-contribution-guidelines","page":"Design Principles","title":"Community contribution guidelines","text":"For a comprehensive set of community contribution guidelines, refer to ColPrac. A relevant point to highlight is that one PR should do one thing. In the context of style, this means that PRs which update the style of a package's code should not be mixed with fundamental code contributions. This separation makes it easier to ensure that large style improvement are isolated from substantive (and potentially breaking) code changes.","category":"section"},{"location":"developers/design-principles/#Open-source-contributions-are-allowed-to-start-small-and-grow-over-time","page":"Design Principles","title":"Open source contributions are allowed to start small and grow over time","text":"If the standard for code contributions is that every PR needs to support every possible input type that anyone can think of, the barrier would be too high for newcomers. Instead, the principle is to be as correct as possible to begin with, and grow the generic support over time. All recommended functionality should be tested, any known generality issues should be documented in an issue (and with a @test_broken test when possible).","category":"section"},{"location":"developers/design-principles/#Generic-code-is-preferred-unless-code-is-known-to-be-specific","page":"Design Principles","title":"Generic code is preferred unless code is known to be specific","text":"For example, the code:\n\nfunction f(A, B)\n    for i in 1:length(A)\n        A[i] = A[i] + B[i]\n    end\nend\n\nwould not be preferred for two reasons. One is that it assumes A uses one-based indexing, which would fail in cases like OffsetArrays.jl and FFTViews.jl. Another issue is that it requires indexing, while not all array types support indexing (for example, CuArrays.jl). A more generic compatible implementation of this function would be to use broadcast, for example:\n\nfunction f(A, B)\n    @. A = A + B\nend\n\nwhich would allow support for a wider variety of array types.","category":"section"},{"location":"developers/design-principles/#Internal-types-should-match-the-types-used-by-users-when-possible","page":"Design Principles","title":"Internal types should match the types used by users when possible","text":"If f(A) takes the input of some collections and computes an output from those collections, then it should be expected that if the user gives A as an Array, the computation should be done via Arrays. If A was a CuArray, then it should be expected that the computation should be internally done using a CuArray (or appropriately error if not supported). For these reasons, constructing arrays via generic methods, like similar(A), is preferred when writing f instead of using non-generic constructors like Array(undef,size(A)) unless the function is documented as being non-generic.","category":"section"},{"location":"developers/design-principles/#Trait-definition-and-adherence-to-generic-interface-is-preferred-when-possible","page":"Design Principles","title":"Trait definition and adherence to generic interface is preferred when possible","text":"Julia provides many interfaces, for example:\n\nIteration\nIndexing\nBroadcasting\n\nThose interfaces should be followed when possible. For example, when defining broadcast overloads, one should implement a BroadcastStyle as suggested by the documentation instead of simply attempting to bypass the broadcast system via copyto! overloads.\n\nWhen interface functions are missing, these should be added to an interface package, like ArrayInterface.jl. Such traits should be declared and used when appropriate. For example, if a line of code requires mutation, the trait ArrayInterface.ismutable(A) should be checked before attempting to mutate, and informative error messages should be written to capture the immutable case (or, an alternative code which does not mutate should be given).\n\nOne example of this principle is demonstrated in the generation of Jacobian matrices. In many scientific applications, one may wish to generate a Jacobian cache from the user's input u0. A naive way to generate this Jacobian is J = similar(u0,length(u0),length(u0)). However, this will generate a Jacobian J such that J isa Matrix.","category":"section"},{"location":"developers/design-principles/#Macros-should-be-limited-and-only-be-used-for-syntactic-sugar","page":"Design Principles","title":"Macros should be limited and only be used for syntactic sugar","text":"Macros define new syntax, and for this reason they tend to be less composable than other coding styles and require prior familiarity to be easily understood. One principle to keep in mind is, \"can the person reading the code easily picture what code is being generated?\". For example, a user of Soss.jl may not know what code is being generated by:\n\n@model (x, Î±) begin\n    Ïƒ ~ Exponential()\n    Î² ~ Normal()\n    y ~ For(x) do xj\n        Normal(Î± + Î² * xj, Ïƒ)\n    end\n    return y\nend\n\nand thus using such a macro as the interface is not preferred when possible. However, a macro like @muladd is trivial to picture on a code (it recursively transforms a*b + c to muladd(a,b,c) for more accuracy and efficiency), so using such a macro for example:\n\njulia> @macroexpand(@muladd k3 = f(t + c3 * dt, @. uprev + dt * (a031 * k1 + a032 * k2)))\n:(k3 = f((muladd)(c3, dt, t), (muladd).(dt, (muladd).(a032, k2, (*).(a031, k1)), uprev)))\n\nis recommended. Some macros in this category are:\n\n@inbounds\n@muladd\n@view\n@named\n@.\n@..\n\nSome performance macros, like @simd, @threads, or @turbo from LoopVectorization.jl, make an exception in that their generated code may be foreign to many users. However, they still are classified as appropriate uses as they are syntactic sugar since they do (or should) not change the behavior of the program in measurable ways other than performance.","category":"section"},{"location":"developers/design-principles/#Errors-should-be-caught-as-early-as-possible,-and-error-messages-should-be-made-contextually-clear-for-newcomers","page":"Design Principles","title":"Errors should be caught as early as possible, and error messages should be made contextually clear for newcomers","text":"Whenever possible, defensive programming should be used to check for potential errors before they are encountered deeper within a package. For example, if one knows that f(u0,p) will error unless u0 is the size of p, this should be caught at the start of the function to throw a domain specific error, for example \"parameters and initial condition should be the same size\".","category":"section"},{"location":"developers/design-principles/#Subpackaging-and-interface-packages-is-preferred-over-conditional-modules-via-Requires.jl","page":"Design Principles","title":"Subpackaging and interface packages is preferred over conditional modules via Requires.jl","text":"Requires.jl should be avoided at all costs. If an interface package exists, such as ChainRulesCore.jl for defining automatic differentiation rules without requiring a dependency on the whole ChainRules.jl system, or RecipesBase.jl which allows for defining Plots.jl plot recipes without a dependency on Plots.jl, a direct dependency on these interface packages is preferred.\n\nOtherwise, instead of resorting to a conditional dependency using Requires.jl, it is preferred one creates subpackages, i.e. smaller independent packages kept within the same GitHub repository with independent versioning and package management. An example of this is seen in Optimization.jl which has subpackages like OptimizationBBO.jl for BlackBoxOptim.jl support.\n\nSome important interface packages to be aware of include:\n\nChainRulesCore.jl\nRecipesBase.jl\nArrayInterface.jl\nCommonSolve.jl\nSciMLBase.jl","category":"section"},{"location":"developers/design-principles/#Functions-should-either-attempt-to-be-non-allocating-and-reuse-caches,-or-treat-inputs-as-immutable","page":"Design Principles","title":"Functions should either attempt to be non-allocating and reuse caches, or treat inputs as immutable","text":"Mutating codes and non-mutating codes fall into different worlds. When a code is fully immutable, the compiler can better reason about dependencies, optimize the code, and check for correctness. However, many times a code making the fullest use of mutation can outperform even what the best compilers of today can generate. That said, the worst of all worlds is when code mixes mutation with non-mutating code. Not only is this a mishmash of coding styles, it has the potential non-locality and compiler proof issues of mutating code while not fully benefiting from the mutation.","category":"section"},{"location":"developers/design-principles/#Out-of-place-and-immutability-is-preferred-when-sufficient-performant","page":"Design Principles","title":"Out-of-place and immutability is preferred when sufficient performant","text":"Mutation is used to get more performance by decreasing the amount of heap allocations. However, if it's not helpful for heap allocations in a given spot, do not use mutation. Mutation is scary and should be avoided unless it gives an immediate benefit. For example, if matrices are sufficiently large, then A*B is as fast as mul!(C,A,B), and thus writing A*B is preferred (unless the rest of the function is being careful about being fully non-allocating, in which case this should be mul! for consistency).\n\nSimilarly, when defining types, using struct is preferred to mutable struct unless mutating the struct is a common occurrence. Even if mutating the struct is a common occurrence, see whether using Setfield.jl is sufficient. The compiler will optimize the construction of immutable structs, and thus this can be more efficient if it's not too much of a code hassle.","category":"section"},{"location":"developers/design-principles/#Tests-should-attempt-to-cover-a-wide-gamut-of-input-types","page":"Design Principles","title":"Tests should attempt to cover a wide gamut of input types","text":"Code coverage numbers are meaningless if one does not consider the input types. For example, one can hit all the code with Array, but that does not test whether CuArray is compatible! Thus, it's always good to think of coverage not in terms of lines of code but in terms of type coverage. A good list of number types to think about are:\n\nFloat64\nFloat32\nComplex\nDual\nBigFloat\n\nArray types to think about testing are:\n\nArray\nOffsetArray\nCuArray","category":"section"},{"location":"developers/design-principles/#When-in-doubt,-a-submodule-should-become-a-subpackage-or-separate-package","page":"Design Principles","title":"When in doubt, a submodule should become a subpackage or separate package","text":"Each package should focus on one core idea. If there's something separate enough to be a submodule, could it instead be a separate well-tested and documented package to be used by other packages? Most likely yes.","category":"section"},{"location":"developers/design-principles/#Globals-should-be-avoided-whenever-possible","page":"Design Principles","title":"Globals should be avoided whenever possible","text":"Global variables should be avoided whenever possible. When required, global variables should be constants and have an all uppercase name separated with underscores (e.g. MY_CONSTANT). They should be defined at the top of the file, immediately after imports and exports but before an __init__ function. If you truly want mutable global style behavior you may want to look into mutable containers.","category":"section"},{"location":"developers/design-principles/#Type-stable-and-type-grounded-code-is-preferred-wherever-possible","page":"Design Principles","title":"Type-stable and type-grounded code is preferred wherever possible","text":"Type-stable and type-grounded code helps the compiler create not only more optimized code, but also faster to compile code. Always keep containers well-typed, functions specializing on the appropriate arguments, and types concrete.","category":"section"},{"location":"developers/design-principles/#Closures-should-be-avoided-whenever-possible","page":"Design Principles","title":"Closures should be avoided whenever possible","text":"Closures can cause accidental type instabilities that are difficult to track down and debug; in the long run it saves time to always program defensively and avoid writing closures in the first place, even when a particular closure would not have been problematic. A similar argument applies to reading code with closures; if someone is looking for type instabilities, this is faster to do when code does not contain closures. See examples here.\n\nFurthermore, if you want to update variables in an outer scope, do so explicitly with Refs or self defined structs.","category":"section"},{"location":"developers/design-principles/#Numerical-functionality-should-use-the-appropriate-generic-numerical-interfaces","page":"Design Principles","title":"Numerical functionality should use the appropriate generic numerical interfaces","text":"While you can use A\\b to do a linear solve inside a package, that does not mean that you should. This interface is only sufficient for performing factorizations, and so that limits the scaling choices, the types of A that can be supported, etc. Instead, linear solves within packages should use LinearSolve.jl. Similarly, nonlinear solves should use NonlinearSolve.jl. Optimization should use Optimization.jl. Etc. This allows the full generic choice to be given to the user without depending on every solver package (effectively recreating the generic interfaces within each package).","category":"section"},{"location":"developers/design-principles/#Functions-should-capture-one-underlying-principle","page":"Design Principles","title":"Functions should capture one underlying principle","text":"Functions mean one thing. Every dispatch of + should be \"the meaning of addition on these types\". While in theory you could add dispatches to + that mean something different, that will fail in generic code for which + means addition. Thus, for generic code to work, code needs to adhere to one meaning for each function. Every dispatch should be an instantiation of that meaning.","category":"section"},{"location":"developers/design-principles/#Internal-choices-should-be-exposed-as-options-whenever-possible","page":"Design Principles","title":"Internal choices should be exposed as options whenever possible","text":"Whenever possible, numerical values and choices within scripts should be exposed as options to the user. This promotes code reusability beyond the few cases the author may have expected.","category":"section"},{"location":"developers/design-principles/#Prefer-code-reuse-over-rewrites-whenever-possible","page":"Design Principles","title":"Prefer code reuse over rewrites whenever possible","text":"If a package has a function you need, use the package. Add a dependency if you need to. If the function is missing a feature, prefer to add that feature to said package and then add it as a dependency. If the dependency is potentially troublesome, for example because it has a high load time, prefer to spend time helping said package fix these issues and add the dependency. Only when it does not seem possible to make the package \"good enough\" should using the package be abandoned. If it is abandoned, consider building a new package for this functionality as you need it, and then make it a dependency.","category":"section"},{"location":"developers/design-principles/#Prefer-to-not-shadow-functions","page":"Design Principles","title":"Prefer to not shadow functions","text":"In Julia, two functions can share the same name if they belong to different namespaces. For example, X.f and Y.f can be two different functions, with different dispatches, but the same name. This should be avoided whenever possible. Instead of creating MyPackage.sort, consider adding dispatches to Base.sort for your types if these new dispatches match the underlying principle of the function. If they don't, it would be preferable to use a different name. While using MyPackage.sort is not conflicting, it is going to be confusing for most people unfamiliar with your code, so MyPackage.special_sort would be more helpful to newcomers reading the code.","category":"section"},{"location":"developers/style-guide/#Style-Guide","page":"Style Guide","title":"Style Guide","text":"Pages = [\"style-guide.md\"]\nDepth = 2:3\n\nThis section describes the coding style rules that apply to our code and that we recommend you to use it also.\n\nIn some cases, our style guide diverges from Julia's official Style Guide (Please read it!). All such cases will be explicitly noted and justified.\n\nOur style guide adopts many recommendations from the BlueStyle. Please read the BlueStyle before contributing to this package. If these guidelines are not followed, your pull requests may not be accepted.\n\ninfo: Info\nThe style guide is always a work in progress, and not all CrystallographyBase code follows the rules. When modifying CrystallographyBase, please fix the style violations of the surrounding code (i.e., leave the code tidier than when you started). If large changes are needed, consider separating them into another pull request.","category":"section"},{"location":"developers/style-guide/#Formatting","page":"Style Guide","title":"Formatting","text":"","category":"section"},{"location":"developers/style-guide/#Run-JuliaFormatter","page":"Style Guide","title":"Run JuliaFormatter","text":"CrystallographyBase uses JuliaFormatter as an auto-formatting tool.\n\nWe use the options contained in .JuliaFormatter.toml.\n\nTo format your code, cd to the CrystallographyBase directory, then run:\n\njulia> using Pkg\n\njulia> Pkg.add(\"JuliaFormatter\")\n\njulia> using JuliaFormatter: format\n\njulia> format(\"docs\"); format(\"src\"); format(\"test\")\n\ninfo: Info\nA continuous integration check verifies that all PRs made to CrystallographyBase have passed the formatter.\n\nThe following sections outline extra style guide points that are not fixed automatically by JuliaFormatter.","category":"section"},{"location":"developers/style-guide/#Use-the-Julia-extension-for-Visual-Studio-Code","page":"Style Guide","title":"Use the Julia extension for Visual Studio Code","text":"Please use Visual Studio Code with the Julia extension to edit, format, and test your code. For the time being, we do not recommend using editors other than Visual Studio Code to edit your code.\n\nThis extension already has JuliaFormatter integrated. So to format your code, follow the steps listed here.","category":"section"},{"location":"lib/public/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"lib/public/#Contents","page":"Public API","title":"Contents","text":"Pages = [\"public.md\"]\nDepth = 3","category":"section"},{"location":"lib/public/#Index","page":"Public API","title":"Index","text":"Pages = [\"public.md\"]","category":"section"},{"location":"lib/public/#Public-interface","page":"Public API","title":"Public interface","text":"","category":"section"},{"location":"lib/public/#Lattice-and-Cell","page":"Public API","title":"Lattice and Cell","text":"","category":"section"},{"location":"lib/public/#Reciprocal-space","page":"Public API","title":"Reciprocal space","text":"Note that we take 2pi as 1, not the solid-state physics convention.","category":"section"},{"location":"lib/public/#Metric-tensor","page":"Public API","title":"Metric tensor","text":"","category":"section"},{"location":"lib/public/#Transformations","page":"Public API","title":"Transformations","text":"","category":"section"},{"location":"lib/public/#Others","page":"Public API","title":"Others","text":"","category":"section"},{"location":"lib/public/#CrystallographyCore.Lattice","page":"Public API","title":"CrystallographyCore.Lattice","text":"Lattice(data::AbstractMatrix)\n\nConstruct a Lattice from a matrix.\n\nnote: Note\nThe basis vectors of the matrix are stored as columns.\n\nExamples\n\njulia> Lattice([\n           1.2 4.5 7.8\n           2.3 5.6 8.9\n           3.4 6.7 9.1\n       ])\nLattice{Float64}\n 1.2  4.5  7.8\n 2.3  5.6  8.9\n 3.4  6.7  9.1\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CrystallographyBase.isrighthanded","page":"Public API","title":"CrystallographyBase.isrighthanded","text":"isrighthanded(lattice::Lattice)\n\nTest whether the basis vectors are defined to be right-handed.\n\nThe basis vectors are right-handed if and only if\n\nmathbfa cdot (mathbfb times mathbfc)  0\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystallographyBase.islefthanded","page":"Public API","title":"CrystallographyBase.islefthanded","text":"islefthanded(lattice::Lattice)\n\nTest whether the basis vectors are defined to be left-handed.\n\nThe basis vectors are left-handed if and only if\n\nmathbfa cdot (mathbfb times mathbfc)  0\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystallographyCore.basisvectors","page":"Public API","title":"CrystallographyCore.basisvectors","text":"basisvectors(lattice::Lattice)\n\nGet the three basis vectors from a lattice.\n\n\n\n\n\nbasisvectors(lattice::ReciprocalLattice)\n\nGet the three basis vectors from a reciprocal lattice.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystallographyBase.latticesystem","page":"Public API","title":"CrystallographyBase.latticesystem","text":"latticesystem(bravais::Bravais)\n\nGet the lattice system of a Bravais lattice.\n\n\n\n\n\nlatticesystem(lattice::Lattice; angletol=1e-5, lengthtol=1e-5)\n\nGet the lattice system of a Lattice.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystallographyBase.latticeconstants","page":"Public API","title":"CrystallographyBase.latticeconstants","text":"latticeconstants(lattice::Lattice)\n\nGet the six lattice constants from a lattice.\n\n\n\n\n\nlatticeconstants(g::MetricTensor)\n\nGet the six lattice constants from a MetricTensor.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystallographyBase.periodicity","page":"Public API","title":"CrystallographyBase.periodicity","text":"periodicity(lattice::Lattice)\n\nGet crystal periodicity in x, y, and z direction from the Lattice.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystallographyCore.Cell","page":"Public API","title":"CrystallographyCore.Cell","text":"Cell(lattice, positions, atoms)\n\nCreate a new cell.\n\nArgument lattice is a Lattice type. Fractional atomic positions positions are given by a vector of N vectors with floating point values, where N is the number of atoms. Argument atoms is a list of N values, where the same kind of atoms need to be the same type.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CrystallographyBase.ReferenceAtom","page":"Public API","title":"CrystallographyBase.ReferenceAtom","text":"ReferenceAtom(label, energy)\n\nAn atom label paired with its reference energy per atom.\n\nArguments\n\nlabel: The atomic label (e.g. a Symbol, String, or custom type).\nenergy: The reference energy per atom.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CrystallographyBase.MagneticAtom","page":"Public API","title":"CrystallographyBase.MagneticAtom","text":"MagneticAtom(label, magnetic_moment)\n\nAn atom label paired with its initial magnetic moment.\n\nArguments\n\nlabel: The atomic label (e.g., a Symbol, String, or custom type).\nmagnetic_moment: The magnetic moment of the atom (scalar for collinear, vector for non-collinear).\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CrystallographyBase.super","page":"Public API","title":"CrystallographyBase.super","text":"super(lattice::Lattice, factors::AbstractMatrix{<:Integer})\nsuper(lattice::Lattice, factors::AbstractVector{<:Integer})\nsuper(lattice::Lattice, factor::Integer)\n\nCreate a supercell from lattice.\n\n\n\n\n\nsuper(cell::Cell, factors::AbstractMatrix{<:Integer})\nsuper(cell::Cell, factors::AbstractVector{<:Integer})\nsuper(cell::Cell, factor::Integer)\n\nCreate a supercell from cell.\n\nnote: Note\nCurrently, only integral replications are supported.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystallographyCore.eachatom","page":"Public API","title":"CrystallographyCore.eachatom","text":"eachatom(cell::Cell)\n\nCreate a generator that iterates over the atoms in a Cell.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystallographyCore.ReciprocalLattice","page":"Public API","title":"CrystallographyCore.ReciprocalLattice","text":"ReciprocalLattice(data::AbstractMatrix)\n\nConstruct a ReciprocalLattice from a matrix.\n\nnote: Note\nThe basis vectors of the matrix are stored as columns.\n\nwarning: Warning\nAvoid using this constructor directly. Use reciprocal instead.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CrystallographyBase.MonkhorstPackGrid","page":"Public API","title":"CrystallographyBase.MonkhorstPackGrid","text":"MonkhorstPackGrid(mesh, is_shift)\n\nRepresent the Monkhorstâ€“Pack grid.\n\nArguments\n\nmesh: A length-three vector specifying the k-point grid (nk_1  nk_2  nk_3) as in Monkhorstâ€“Pack grids.\nis_shift: A length-three vector specifying whether the grid is displaced by half a grid step in the corresponding directions.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CrystallographyCore.reciprocal","page":"Public API","title":"CrystallographyCore.reciprocal","text":"reciprocal(lattice::Lattice)\nreciprocal(lattice::ReciprocalLattice)\n\nGet the reciprocal of a Lattice or a ReciprocalLattice.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystallographyBase.MetricTensor","page":"Public API","title":"CrystallographyBase.MetricTensor","text":"MetricTensor(ðš::AbstractVector, ð›::AbstractVector, ðœ::AbstractVector)\n\nGenerate a MetricTensor from the three basis vectors.\n\n\n\n\n\nMetricTensor(lattice::Lattice)\n\nGenerate a MetricTensor from a Lattice.\n\n\n\n\n\nMetricTensor(a, b, c, Î±, Î², Î³)\n\nGenerate a MetricTensor from the six cell parameters.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CrystallographyBase.lengthof","page":"Public API","title":"CrystallographyBase.lengthof","text":"lengthof(ðš::ReducedCoordinates, g::MetricTensor)\n\nGet the length of an atomic coordinates.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystallographyBase.distance","page":"Public API","title":"CrystallographyBase.distance","text":"distance(ðš::ReducedCoordinates, ð›::ReducedCoordinates, g::MetricTensor)\n\nGet the distance between two atomic coordinates.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystallographyBase.PrimitiveFromStandardized","page":"Public API","title":"CrystallographyBase.PrimitiveFromStandardized","text":"PrimitiveFromStandardized(tf::AbstractMatrix)\n\nConstruct the transformation from a standardized cell to a primitive cell.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CrystallographyBase.StandardizedFromPrimitive","page":"Public API","title":"CrystallographyBase.StandardizedFromPrimitive","text":"StandardizedFromPrimitive(tf::AbstractMatrix)\n\nConstruct the transformation from a primitive cell to a standardized cell.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CrystallographyBase.cellvolume","page":"Public API","title":"CrystallographyBase.cellvolume","text":"cellvolume(a, b, c, Î±, Î², Î³)\n\nCalculate the cell volume from 6 cell parameters.\n\n\n\n\n\ncellvolume(lattice::Lattice)\ncellvolume(cell::Cell)\n\nCalculate the cell volume from a Lattice or a Cell.\n\n\n\n\n\ncellvolume(g::MetricTensor)\n\nCalculate the cell volume from a MetricTensor.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystallographyBase.crystaldensity","page":"Public API","title":"CrystallographyBase.crystaldensity","text":"crystaldensity(lattice::Lattice, atoms)\ncrystaldensity(cell::Cell)\n\nCalculate the density of a crystal structure.\n\nHere, atoms is an iterable of atomic numbers, element names, symbols, or Mendeleev.Elements. You can extend the atomicmass method to work with custom types.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystallographyBase.atomicmass","page":"Public API","title":"CrystallographyBase.atomicmass","text":"atomicmass(element::Element)\natomicmass(i::Union{AbstractString,Integer,Symbol})\n\nReturn the atomic mass of an element.\n\nwarning: Warning\nThis function is by default not implemented. You need to load either package Mendeleev.jl or PeriodicTable.jl to use it.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CrystallographyBase.formation_energy","page":"Public API","title":"CrystallographyBase.formation_energy","text":"formation_energy(cell::Cell, energy, component_energies)\n\nCalculate the formation energy per atom for a Cell.\n\nThe formation energy per atom is:\n\nE_f = fracE_texttotal - sum_i E_iN\n\nwhere E_texttotal is the total energy of the compound, E_i is the reference energy per atom for the i-th atom in the cell, and N is the total number of atoms.\n\nArguments\n\ncell: A Cell whose atoms field provides the atom labels.\nenergy: Total energy of the compound.\ncomponent_energies: A mapping from atom label to reference energy per atom.\n\n\n\n\n\nformation_energy(cell::Cell{L,P,<:ReferenceAtom}, energy)\n\nCalculate the formation energy per atom when each atom in cell is a ReferenceAtom, so that reference energies are embedded in the cell itself and no separate component_energies mapping is required.\n\nArguments\n\ncell: A Cell whose atoms are ReferenceAtom values.\nenergy: Total energy of the compound.\n\n\n\n\n\n","category":"function"},{"location":"#CrystallographyBase","page":"Home","title":"CrystallographyBase","text":"Documentation for CrystallographyBase.\n\nSee the Index for the complete list of documented functions and types.\n\nThe code, which is hosted on GitHub, is tested using various continuous integration services for its validity.\n\nThis repository is created and maintained by @singularitti, and contributions are highly welcome.","category":"section"},{"location":"#Package-features","page":"Home","title":"Package features","text":"Define crystal lattices and cells\nCompute reciprocal lattices\nGenerate supercells and k-point grids\nEnable math utilities for crystal properties","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"The package can be installed with the Julia package manager. From the Julia REPL, type ] to enter the Pkg mode and run:\n\npkg> add CrystallographyBase\n\nOr, equivalently, via Pkg.jl:\n\nimport Pkg; Pkg.add(\"CrystallographyBase\")","category":"section"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"STABLE â€” documentation of the most recently tagged version.\nDEV â€” documentation of the in-development version.","category":"section"},{"location":"#Project-status","page":"Home","title":"Project status","text":"The package is developed for and tested against Julia v1.6 and above on Linux, macOS, and Windows.","category":"section"},{"location":"#Questions-and-contributions","page":"Home","title":"Questions and contributions","text":"You can post usage questions on our discussion page.\n\nWe welcome contributions, feature requests, and suggestions. If you encounter any problems, please open an issue. The Contributing page has a few guidelines that should be followed when opening pull requests and contributing code.","category":"section"},{"location":"#Manual-outline","page":"Home","title":"Manual outline","text":"Pages = [\n    \"man/installation.md\",\n    \"man/definitions.md\",\n    \"man/examples.md\",\n    \"man/troubleshooting.md\",\n    \"developers/contributing.md\",\n    \"developers/style-guide.md\",\n    \"developers/design-principles.md\",\n]\nDepth = 3","category":"section"},{"location":"#Library-outline","page":"Home","title":"Library outline","text":"Pages = [\"lib/public.md\", \"lib/internals/lattices.md\"]","category":"section"},{"location":"#main-index","page":"Home","title":"Index","text":"Pages = [\"lib/public.md\"]","category":"section"},{"location":"man/examples/#Examples","page":"Examples","title":"Examples","text":"Pages = [\"examples.md\"]\nDepth = 2","category":"section"},{"location":"man/examples/#Creating-a-Cell","page":"Examples","title":"Creating a Cell","text":"To create a Cell, we first need to create a Lattice. There are multiple ways of doing it. For example, if we know the six lattice constants, we can do\n\nusing CrystallographyBase, Unitful, UnitfulAtomic\nlatticeâ‚ = Lattice(4u\"nm\", 180u\"bohr\", 3u\"angstrom\", 90, 90, 90)\n\nOr, equivalently,\n\nlatticeâ‚ == Lattice([\n    4u\"nm\" 0u\"m\" 0.0u\"cm\"\n    0u\"cm\" 180.0u\"bohr\" 0u\"m\"\n    0u\"bohr\" 0u\"nm\" (3//1)*u\"angstrom\"\n])\n\nThen we can add atoms and their positions (in crystal coordinates):\n\nlatticeâ‚‚ = [\n    -3.0179389205999998 -3.0179389205999998 0.0000000000000000\n    -5.2272235447000002 5.2272235447000002 0.0000000000000000\n    0.0000000000000000 0.0000000000000000 -9.7736219469000005\n]\npositions = [[2 / 3, 1 / 3, 1 / 4], [1 / 3, 2 / 3, 3 / 4]]\natoms = [1, 1]\ncell = Cell(latticeâ‚‚, positions, atoms)","category":"section"},{"location":"man/examples/#Reciprocal-space","page":"Examples","title":"Reciprocal space","text":"To get the reciprocal lattice, we run reciprocal:\n\nreciprocal(latticeâ‚)\n\nnote: Note\nNever use ReciprocalLattice directly unless you know what you are doing!","category":"section"},{"location":"man/examples/#Supercell-generation","page":"Examples","title":"Supercell generation","text":"We can specify the replication factors in each direction in the following ways:\n\nsuper(latticeâ‚, [2, 3, 4])\nsuper(latticeâ‚, 3)\nsuper(cell, [2, 3, 4])\nsuper(cell, 3)\n\nIf only one integer is provided, it will be used in all three spatial directions.","category":"section"},{"location":"man/installation/#Installation-Guide","page":"Installation Guide","title":"Installation Guide","text":"Pages = [\"installation.md\"]\nDepth = 2:3\n\nHere are the installation instructions for package CrystallographyBase. If you have trouble installing it, please refer to our Troubleshooting page for more information.","category":"section"},{"location":"man/installation/#Install-Julia","page":"Installation Guide","title":"Install Julia","text":"First, you should install Julia. We recommend downloading it from its official website. The recommended way is to use a version manager Juliaup.\n\nInstall the latest Julia version by running this in your terminal:\n\ncurl -fsSL https://install.julialang.org | sh\n\non Unix-type systems. For Windows users, run\n\nwinget install julia -s msstore\n\nOnce installed, julia will be available via the command line interface. This will install the Juliaup installation manager, which will automatically install Julia and help keep it up to date. The command juliaup is also installed. To install different Julia versions see juliaup --help. There is a short video introduction to Juliaup made by its authors.\n\nPlease follow the detailed instructions on its website if you have to build Julia from source. Some computing centers may have Julia preinstalled. Please contact your administrator for more information in that case. Additional information can be found here: how to set up Julia on HPC systems.\n\nIf you have Homebrew installed, open Terminal.app and type\n\nbrew install julia\n\nto install it as a formula.\n\nIf you are also using macOS and want to install it as a prebuilt binary app, type\n\nbrew install --cask julia\n\ninstead.","category":"section"},{"location":"man/installation/#Which-version-should-I-pick?","page":"Installation Guide","title":"Which version should I pick?","text":"You can install the current stable release or the long-term support (LTS) release.\n\nThe current stable release is the latest release of Julia. It has access to newer features, and is likely faster.\nThe long-term support release is an older version of Julia that has continued to receive bug and security fixes. However, it may not have the latest features or performance improvements.\n\nMost users should install the 'Current stable release' and update their Julia version whenever a new version is released. Note that any code you write on one version of the current stable release will continue to work on all subsequent releases.\n\nUsers in restricted software environments, where enterprise IT controls software installations, may benefit from installing the long-term support release to reduce the frequency of updates.\n\nVersions above v1.3, especially the latest stable ones, are strongly recommended. This package is highly unlikely to work on v1.0 and earlier versions. Since the Julia team has set v1.6 as the LTS release, we will gradually drop support for versions below v1.6.\n\nJulia and Julia packages support multiple operating systems and CPU architectures; check this table to see if it can be installed on your machine. For Mac computers with M-series processors, this package and its dependencies may not work. Please install the Intel-compatible version of Julia (for macOS x86-64) if any platform-related error occurs.","category":"section"},{"location":"man/installation/#Install-the-package","page":"Installation Guide","title":"Install the package","text":"The following installation steps are demonstrated using macOS as the standard platform:\n\nOpen the Terminal app, and type julia to start an interactive session (known as the REPL).\nRun the following commands and wait for them to finish:\njulia> using Pkg\n\njulia> Pkg.update()\n\njulia> Pkg.add(\"CrystallographyBase\")\nRun\njulia> using CrystallographyBase\nand have fun!\nPlease keep the Julia session active while using it. Restarting the session may take some time.\n\nIf you want to install the latest in-development (probably buggy) version of CrystallographyBase, type\n\nusing Pkg\nPkg.update()\npkg\"add https://github.com/MineralsCloud/CrystallographyBase.jl\"\n\nin the second step above.","category":"section"},{"location":"man/installation/#Update-the-package","page":"Installation Guide","title":"Update the package","text":"Please watch our GitHub repository for new releases. Once we release a new version, you can update CrystallographyBase by typing\n\nusing Pkg\nPkg.update(\"CrystallographyBase\")\nPkg.gc()\n\nin the Julia REPL.","category":"section"},{"location":"man/installation/#Uninstall-and-then-reinstall-the-package","page":"Installation Guide","title":"Uninstall and then reinstall the package","text":"Errors may occur if the package is improperly installed. In this case, you may want to uninstall and reinstall the package. Here is how to do that:\n\nTo uninstall, in a Julia session, run\njulia> using Pkg\n\njulia> Pkg.rm(\"CrystallographyBase\")\n\njulia> Pkg.gc()\nPress Ctrl+D to quit the current session. Start a new Julia session and reinstall CrystallographyBase.","category":"section"}]
}
